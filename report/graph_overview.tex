\documentclass[letter, 12pt, english, draft]{article}
\usepackage{mikkel}
\usepackage[ruled,vlined]{algorithm2e}
\newcommand{\halfblankline}{\quad\vspace{-0.5\baselineskip}\pagebreak[3]}
\newcommand{\propSol}[2]{\texttt{Problem:}\\
#1\\
\texttt{Solution:}\\
#2
\halfblankline
}
\acroterm{ch}{Cluster Heads}{CH}
\acroterm{gabe}{Gabriel Graph}{GG}
\acroterm{udg}{Unit Disk Graph}{UDG}
\acroterm{manet}{Mobile Ad-Hoc Network}{MANET}
\acroterm{anet}{Ad-Hoc Network}{ANET}
\acroterm{rng}{Relative Neighbourhood Graph}{RNG}
\title{Energy Affluent Mobile Ad-Hoc Networks}
\author{Mikkel Kj√¶r Jensen}
\date{\today}
\begin{document}

\pagestyle{plain}

\section{Routing graph}
\tigfig{hidden_terminal}{}

\tigfig{graphTop}{The hidden terminal problem. In this example the third node from the left is communicating with the middle node (symbolised by the grey colour) Since the transmission cannot reach the leftmost node, it is not possible for it to do collision avoidance}

\tigfig{different_radius}{A node with different broadcast ranges. The first solid circle is the default broadcast range of the node, while the second dashed circle is the maximum range it can broadcast.}

\tigfig{node_different_radius}{Two nodes with different broadcast ranges. The black node is not adjacent to the grey node, but the grey node is adjacent to the black node - thus one-way communication could take place.}

There does currently not exist a consensus on what   routing graph does not have a singular structure. Since nodes will be able to broadcast and receive signals to/from nodes in a radius (at least under optimal conditions) around them, the most routing graph with the maximum number of edges will not be planar. Furthermore, while most routing algorithms assume so, the edges do not have to be bidirectional. One could easily imagine a scenario where heterogeneous ad-hoc nodes had different broadcast radii, leading to cases where certain nodes could receive other nodes broadcast through 1 jump, but would have to route through several nodes to get the message back.

Much of the literature bases their graph on the \udg, where there exist an edge between node $n_1$ and $n_2$ iff $|\overline{n_1n_2}| \leq 1$ i.e. the distance between the two nodes are less or equal to 1 unit  \cite{gopher}. In this case we assume that all the nodes have the same communication range, and so every edge indicates that the two nodes can talk together. However it is clear that a \udg is not always planar, which is the preferred structure for a underlying graph in \anet. 

The planar graph is a sensible choice, since it simplifies routing immensely, which is why many traditionally popular routing algorithms also make this assumption. There are several methods for turning the underlying structure into a planar graph (i.e. making sure that for any given node, the only neighbours they have are the ones that do not violate the planarity of the graph, were it to be represented as a graph), and keeping it so for the lifetime of the network. 

There exist the following common methods for making the graph planar \todo{explain}. More exist, but they have yet to be widely adopted by the research community.
\begin{description}
\item[The \gabe] Two nodes $n_1$ and $n_2$ only share an edge iff the circle that has $\overline{n_1n_2}$ as its diameter does not contain a node $n_3$ \cite{gopher}. 
\item[The \rng:] Two nodes $n_1$ and $n_2$ share an edge if there is no node $n_3$ such that $|\overline{n_1n_3}|, |\overline{n_2n_3}| \leq |\overline{n_1n_2}|$ (i.e. $n_3$ is closer to both $n_1$ and $n_2$ than $n_1$ and $n_2$ are to each other).
\end{description}

Since we are dealing with mobile units, the topology of the graph will change as the nodes move around, which means that we will need a solution that updates the topology continuously, and not having to start over from scratch each time. Since we are dealing transmitting nodes, it is important to note that in practise changes is when a node leaves or enters another nodes radius (it does not matter which of them moves). While environmental factors will of course dampen signals, we can in most cases assume that the radio signal will behave more omni-directional than directional. Assuming we are sure that the desired node is in its transmit radius, a node can simply transmit its message (with some kind of recipient id --- unless it wants to flood the network), and hope that it avoids message collision. \todo{work in that we are working in an ideal situation, and that reality is messy}  

In practise no graph can be said to be entirely static. Even in cases where the nodes are completely stationary, all nodes in the \anet will eventually run out of energy or fail. The routing graph must therefore be amendable, even if the nodes are not moving. 

\section{Routing Algorithms}

The biggest conceptual difference for routing/shortest path algorithms in a \manet compared to main-stray routing/shortest path algorithms, is the loss of global overview that these algorithms employ --- such as relaxing a specific nodes' edges at a specific time. There exist distributed version of some of the ``classic'' routing algorithms, but their usefulness may be limited in a mobile network, since they will have to be recomputed either each time a node wants to transmit a message, or each time the underlying graph changes.

When routing a message from the source to the sink, it is important to distinguish the message that is being transmitted and the nodes that are transmitting. The transmitted message does not only include the information that is intended for the node at the sink, but also extra meta-data needed for routing. This includes time-to-live, position of the source node, position of the sink, message id etc. The nodes are all assumed to use the same routing algorithm, and at least know who their neighbours are.

Most of the following algorithms will mostly be based around the idea of \emph{local routing algorithms}. 

Paraphrasing \cite{compass}, a local routing algorithm is an algorithm that for fills the following criteria:
\begin{enumerate}
\item Each message will have a limited memory to store information about a constant number of verticess, but it have full access to the position of the sink and the source. At no point does the message have full knowledge of the entire graph. 
\item Let $s$ be the source of the message, $t$ the sink, and $v$ be a node in the graph that can be reached from $s$. Arriving at $v$, the message can then use the information $v$ has stored about its neighbours, as well as its logical edges to the neighbours. Based on this information, one of the neighbours of $v$ is chosen as the next receiver of the message, unless $v = t$, in which case the message will not be propagated.
\item A message will not leave information that the nodes routing algorithm will be able to use. In this sense nodes are considered stateless.\end{enumerate}

Taken together, the first and third property says that the state of routing process is contained in the message being routed, while the control and logic of the routing is contained in the nodes, which only acts upon the information in the message received and their knowledge about their neighbours. Since all the nodes are running the same routing algorithm, a well designed routing algorithm ensures that the message will arrive.

\label{record-recived}
It is worth noting that the 3 properties only apply to the routing algorithm itself, and not the layers below. This is an important distinction, as most routing solutions require reach node to track which messages it receives, so that future copies of the same message can be ignored in the future --- ensuring that a message will not needlessly congest the network. In the same vain, some routing solutions, such as \cite{speed} has its lower layers use this information to apply congestion avoidance. Another application is to use the messages being passed around to keep track of which nodes are still active --- this is usually combined with diagnostic or ``accounting'' messages\todo{Find ref}. 

\subsection{Categories of Routing algorithms}
When a routing algorithm wants to send a message or a number of messages from a sink to a source, an important question is whether there should first be sent a utility message to discover a path from the source to the sink, and then have all messages follow the established path, or each message should find its own way from the source to the sink.

If the algorithm chooses the first way, then there has been established two fundamentally different principles that can be applied.
\begin{description}
\route{Destination Sequential Distance Vector (DSDV)}
{With the DSDV, every node tries to remember as many as possible paths to the other nodes in the graph. The mapping from nodes to paths can either just be the next neighbour that a message needs to be routed to, or the entire path. In pure implementations of DSDV, each node knows a path to all other nodes. The advantage of DSDV is that when the information is correct it saves a lot of work, and is fast, while the disadvantage is that it is memory intensive and thus has problems scaling to large \manet. Depending on how much the nodes move, it could also be prone to contain outdated information.
%In order to find a path DSDV uses a distributed version of Bell
}
{\cite{DSDV}}

\route{Ad-Hoc On-demand Distance Vector (AODV)}
{With the AODV, a node only records a path from any pair of nodes if it becomes relevant. This is done by a path discovery phase, where a route request package (RREQ) is sent from the source. When the RREQ arrives at a node it checks whether the node knows of a path to the sink. If the nodes does not, then the RREQ writes the node it was sent from and the number of hops to the current node, and is sent along. If the current node does know a path to the sink, then a bidirectional path is established from the source to the sink, so that messages can be exchanged.

The AODV has route maintenance mechanism. Let node $n_k$ and $n_{k+1}$ be the [$k$]th and [$t+1$]th node on the path from the source to the sink for $k \in \N$. If $n_{k+1}$ is no longer adjacent to $n_{k}$, then it will begin a tear-down protocol that will delete its routing table, and then tell the [$k-1$]th to do the same until the message arrives at the source, which can then rebuild the path if the path is still relevant.
AODV does not describe any specific routing algorithm in order to establish a route.}
{\cite{larMotion, AODV}}

\end{description}

Routing algorithms suited for \manet s can be sorted into the following categories:
\begin{description}
\route{Flooding}
{The simplest of the routing algorithms. The entire network is flooded with the message, ensuring that the message eventually reaches the sink. We can be sure that the message will not flood the network forever, thanks to the recording system detailed in section \ref{record-recived}. If the sink can be reached from the source, then flooding is  guarantied to work, but uses a lot of bandwidth.} 
{\cite{larMANET, Sur2}} 

\route{Restricted Direction Routing (RDR)}
      {Restricted Directed Routing is an algorithm that can be described as a kind of directed flooding. Let G be a geometrical shape. G is now placed such that it now contains both the source and the sink are both contained in G (preferably with a non-zero margin, to counter act any movement on the sinks part). The source now floods all nodes inside G, hopefully reaching the sink. Once a route to the sink has been established, the information

The there is no standard shape, but possible choices includes Linear Swept Sphere, Circle or Rectangle \todo{Include figure of them all}. Obviously, RDR is only applicable when the source has an idea of the location of the sink, otherwise another algorithm (like flooding) has to be employed. In the case where both nodes wants to contact each other (say, in situations where timers are involved), a bi-directional RDR can take place, where each node tries to find each other, until both diffusion reach each other, and a path can be established.}
{\cite{larMANET}}

\route{Directed Diffusion (DD)}
{}

\route{Greedy routing} 
{Greedy routing is a simple routing scheme that always chooses to route the message to that of its neighbours that is closest to the sink. In the case where the message arrives at a node $n$, where all of $n$'s neighbours are farther away from the sink than $n$, then no action is specified, and the message will not be delivered. The greedy algorithm thus offers no guarantee in delivering the message, but in practise it improves as the density of the network increases.}
{}

\route{Geometrical routing}
{Geometrical routing uses the location of the current node and the location of the sink. There exist many different kinds of routing algorithms, but common for them is that unlike the greedy routing technique, they will transmit the message to a node that is not necessarily the closer node. This ensures that the message will eventually reach the sink. An example of a Geometrical algorithm could be the OFR \cite{gopher} routing algorithm, which uses the line-segments between the sink and the source to find which faces in the graph it needs to route to eventually arrive at the sink.}
{}

\route{Shortest path} 
{The shortest path technique is to use distributed versions of the shortest path algorithms in order to find the shortest path from either one node to another, or from all nodes to all other nodes. As one might imagine, this approach has problems in mobile networks, where the structure of the graph can be in constant flux. Even in static networks the algorithms incur memory problems, since in the all-to-all solution, since for any node with a message for any node in the network must know which neighbour it must send it to get the most efficient route.}
{}  

\end{description}

Different routing algorithms make different assumptions about the underlying nature of the mobility of the graph. There are several routing algorithms \cite{adaptive, two-tier} that assumes a number of permanently stationary nodes or sensors as a part of the infrastructure, while still having a number of mobile nodes that need to receive information. 

In practical situations the system will have to deal with all the problems inherent in wireless communication, such as the hidden terminal problem and message collision. To avoid these, having a lower communications layer that took care of this would be preferable to implementing it in the algorithm itself (though care should be taken to ensure that the algorithm is build to withstand these conditions).

\section{Problems we have with movement}





Movement presents us with the following problems:

\begin{itemize}
\item Changes underlying graph
\item Invalidates location information about the node
\item If the node is part of path from \emph{a} to \emph{b} (and the node is neither), which is stored and which is believed to be used again, then that path may fail, and a longer path may have to be taken. In degenerate cases this may lead to situations where the new optimal path will lead away from the absolute coordinates of the end node.
\item The moving node may partition a network into 2 separate networks, if the node was the only node the 2 networks could communicate through
\item The moving node may create a link between 2 previously separate networks
\item The node may move into a position that creates a better path than the one before it moved - however, the surrounding nodes needs to be aware of it
\end{itemize}

The movement creates the need for the following solutions:
\begin{itemize}
\item There needs to be a way to restructure the underlying graph so that it reflects the movement of the node \cite{practical}
\item The location of the moving node needs to be updated. This does not necessary need to be done to all the nodes in the network, nor all the nodes that knew it before. There are many schemes for this, such as GLS \cite{scaleLocation} which partitions the world into squares, and then partitions these squares into other squares, resulting in several layers of squares. In each of these squares, there is a single node that knows the location of the node (and a scheme to find it).
\item Depending on implementation there may be no problem (there is a time-out system that detects that the message did not arrive, the node right before the missing node reports back that it could not deliver the message etc.). Finding a new path should not be a real problem unless the algorithm employed is a greedy algorithm (i.e. an algorithm that will always choose to go to the node that brings it closest to the absolute coordinates of the goal node).
\item If the network is partitioned, then the best course of action is to let the two networks figure out that the other part isn't available. Some kind of timeout mechanism in the location mechanism would seem like the most straightforward path
\item If connection is established between network \emph{a} and network \emph{b}, there should be a mechanism so that network \emph{a} and inform network \emph{b} of its nodes, and vice versa. Optimally this should already be a part of how nodes advertise their presence.
\item In order to take advantage of new nodes, they need to advertise their presence (and their location) to the entire system 
\end{itemize}

\section{Fundamental Graph Routing problems}

A fundamental problem that has to be answered in any \manet is now to deal with situations where the sink no longer has the location the source routed the message to (but still reachable from the source). There are several solutions to this problem:

\begin{itemize}
\item Once the sink has moved a certain distance away from its neighbours, it could inform them of its current position, and then flood its surroundings of its current location. Effectively this solution creates an area of way-points that can be used to find the sink.
\item If we are dealing with a Cluster method (see Section \ref{cluster methods}), then the sink only needs to inform its old \ch that it has moved to a new \ch, and in the same way as before, the message will catch up with the sink.
\item Instead of getting the exact location of the sink at the beginning and then routing blindly towards that location, layers of node location ``servers'' can be established. A server may not know where any given node is, but it may know where a server (which is physically closer to the sink) that either knows the location of the sink, or knows a server closer to the sink \ldots and so on until we find a server that knows where the sink is. Thus the sink will eventually be found.
\end{itemize}

Another problem found in Graph routing is that of security. Unless some kind of security system is employed, a malicious node can not only impersonate other nodes, but it can also sniff the messages that are transmitted in its area (not only the ones that are directly sent to it). Further a malicious node can spam the network with bogus messages, both congestion the network, as well as draining the networks power. One proposed solution to this problem is to include secure keys that uniquely identify each node. However, without a central key-server (both for distribution and authentication), this is not practical.

\section{Cluster methods}
\label{cluster methods}
Cluster methods are routing algorithms where certain nodes have been chosen to be \ch. All nodes have exactly 1 cluster head that they communicate with. While it is true that most of the time the nodes that belong to a certain \ch is its direct neighbours, some schemes includes nodes that are farther away, in order to reduce the number of \ch. The idea behind \ch are to include a layer specialisation in the network, and adding some of the advantages of centralisation with a still decentralised system. 

Sometimes several levels of \ch are implemented, where we have second, third etc. levels of \ch, which administrates the \ch one level beneath them.  

In order to improve the routing, \ch s are almost always accompanied by \emph{gateway nodes}. Gateway nodes are nodes that connect two clusters. \cite{spanners} defines a gateway node as follows:
Let C(p) be the set of nodes that has the cluster p as its \ch (this includes p). Then for a pair of \ch s $c_1, c_2$ if there exists a pair of nodes $p_1 \in C(c_1), p_2 \in C(c_2)$ such that $p_1$ and $p_2$ can communicate with each other in the graph, then $p_1$ and $p_2$ are gateway nodes (and in particular they are the only gateway nodes between $c_1$ and $c_2$.  

Some of the practical advantages are:
\begin{itemize}
\item Depending on the implemented location schemes, the \ch can cut down on the number of necessary transmissions needed to check whether nodes are alive or not.
\item It can make routing simpler, since all transmissions will have to go though the node gateways or up through the chain of \ch s. Only the \ch and gateway nodes needs to have their location database updated. All data will of course till have to be transmitted through regular nodes, but instead of having to route directly from the source to the sink, it will route from \ch to gateway, gateway to \ch and so on until it reaches the sink.
\end{itemize}

\ch is to divide any communication between nodes into 3 stages: 1) From the source to the local \ch, 2) From the local \ch to the \ch closest to the sink and 3) from the \ch closets to the sink to the sink itself\footnote{If either \ch is the sink or the source, and the first or third part is of course eliminated}. This is thus one way to decrease the number of nodes that needs to keep track of other nodes. Furthermore, if gateway nodes are employed, this can ease the routing problem, as a lengthy route is divided into shorter trips.  

However, since we are introducing a layer of centralisation, it is also clear that there must be a system in place to detect and replace a \ch should it fail (and to elect it in the first place). An often used system is a voting system, or an selection algorithm (based hash value of the node's id, its MAC value etc.). 

\bibliographystyle{plain}
\bibliography{references}{}

\end{document}
